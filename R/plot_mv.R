#' Mean-Variance Plot
#'
#' This function visualizes the mean-variance relationship of omic data before
#' or after modeling.
#'
#' @param dat Omic data matrix or matrix-like object with rows corresponding to
#'   probes and columns to samples. Data are presumed to be normalized prior to
#'   visualization. Alternatively, a fitted model object of class
#'   \code{\link[limma]{MArrayLM}} or \code{\link[DESeq2]{DESeqDataSet}}. See Details.
#' @param trans Data transformation to be applied to probewise means
#'   (if \code{trans = "rank"}) or standard deviations (if \code{trans = "log"} or
#'   \code{"sqrt"}). Not all transformations are appropriate for all data types.
#'   See Details.
#' @param span Width of the LOWESS smoothing window as a proportion.
#' @param ptsize Size of data points in the plot.
#' @param main Optional plot title.
#' @param legend Legend position. Must be one of \code{"outside", "bottomleft",
#'   "bottomright", "topleft",} or \code{"topright"}. Only relevant if \code{dat}
#'   is an \code{MArrayLM} object created by a call to \code{\link[limma]{eBayes}}
#'   with \code{trend = TRUE}. See \code{\link[limma]{squeezeVar}} for more details.
#' @param hover Show probe name by hovering mouse over data point? If \code{TRUE},
#'   the plot is rendered in HTML and will either open in your browser's graphic
#'   display or appear in the RStudio viewer. Probe names are extracted from
#'   \code{dat}.
#'
#' @details
#' Mean-variance (MV) plots are a quick and easy way to visualize the relationship
#' between the first two moments of probewise data distributions. When used prior to
#' modeling, they may help better understand the internal structure of the data
#' and inspect for potential outliers. The effects of filtering and transformations
#' can also be readily evaluated. When applied after modeling, MV plots help assess
#' the assumptions of the regression.
#'
#' If \code{dat} is a matrix, then it is presumed to be filtered and normalized prior
#' to plotting. For count data, this means undergoing some sort of variance
#' stabilizing transformation, such as \code{\link[edgeR]{cpm} (with \code{log = TRUE}),
#' \link[DESeq2]{vst}, \link[DESeq2]{rlog}}, etc. If \code{dat} is of class
#' \code{MArrayLM} or \code{DESeqDataSet}, then the y-axis will represent the standard
#' deviations of the model residuals. For the latter class of objects, a residual
#' matrix is generated by subtracting the RLE-normalized signal matrix from the
#' RLE-normalized counts on the log2-counts per million scale. An error message will
#' be generated if \code{dat} is a \code{DESeqDataSet} that has not been through the
#' complete modeling pipeline.
#'
#' By default, rank-transformed means are plotted against standard deviations for
#' each probe. This is a reasonable choice for most data types. It is also common in
#' the microarray literature to plot probewise means against log-transformed standard
#' deviations, while the authors of \code{limma} recommend the square-root transform
#' for count data on the log2-counts per million scale. The latter transformation is
#' not recommended for modeled data and will generate a warning if passed in
#' conjunction with an \code{MArrayLM} or \code{DESeqDataSet} object.
#'
#' \code{plot_mv} fits a smooth curve to the points using a LOWESS local regression
#' model with a smoothing window given by \code{span}. If standard errors were
#' moderated with \code{eBayes}, then prior variance will also be plotted as either
#' a horizontal line or a smooth curve, depending on whether a global or
#' intensity-dependent prior was used. If robust empirical Bayes was used to create
#' \code{dat}, then outlier variances are highlighted. See \code{\link[limma]
#' {squeezeVar}} for more details.
#'
#' @references
#' Huber, W., Hedebreck, A., SÃ¼ltmann, H., Poustka, A. & Vingron, M. (2002).
#' "Variance Stabilization Applied to Microarray Data Calibration and to the
#' Quantification of Differential Expression." \emph{Bioinformatics}, \emph{18}:1,
#' S96-2104.
#' \url{https://www.ncbi.nlm.nih.gov/pubmed/12169536}
#'
#' Sartor, M.A., Tomlinson, C.R., Wesselkamper, S.C., Sivaganesan, S., Leikauf, G.D.
#' & Medvedovic, M. (2006). "Intensity-based hierarchical Bayes method improves
#' testing for differentially expressed genes in microarray experiments." \emph{BMC
#' Bioinformatics}, \strong{7}:538.
#' \url{http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-538}
#'
#' Law, C.W., Chen, Y., Shi, W., & Smyth, G.K. (2014). "voom: precision weights unlock
#' linear model analysis tools for RNA-seq read counts." \emph{Genome Biology},
#' \strong{15}:R29.
#' \url{https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29}
#'
#' @examples
#' mat <- matrix(rnorm(1000 * 10), nrow = 1000, ncol = 10)
#' plot_mv(mat, trans = "log")
#'
#' library(limma)
#' grp <- rep(c("ctl", "trt"), each = 5)
#' des <- model.matrix(~ grp)
#' fit <- eBayes(lmFit(mat, des), trend = TRUE)
#' plot_mv(fit)
#'
#' @seealso
#' \code{\link[vsn]{meanSdPlot}, \link[limma]{plotSA}, \link[limma]{voom}}
#'
#' @export
#' @importFrom limma getEAWP
#' @importFrom DESeq2 counts
#' @importFrom edgeR DGEList calcNormFactors cpm
#' @importFrom matrixStats rowSds
#' @import dplyr
#' @importFrom purrr map_lgl
#' @import ggplot2
#' @importFrom plotly ggplotly
#'

plot_mv <- function(dat,
                  trans = 'rank',
                   span = 0.5,
                 ptsize = 0.25,
                   main = NULL,
                 legend = 'outside',
                  hover = FALSE) {

  # Preliminaries
  if (nrow(dat) < 2L) {
    stop('plot_mv requires at least 2 probes to fit a mean-variance trend.')
  }
  if (is(dat, 'MArrayLM') && is.null(dat$t) && is.null(dat$F)) {
    warning('Standard errors for dat have not been moderated. Consider re-running ',
            'plot_mv after shrinking residual variance with eBayes. See ?eBayes ',
            'and ?squeezeVar for more info.')
  } else if (is(dat, 'DESeqDataSet') && is.null(assays(dat)[['mu']])) {
    stop('If dat is a DESeqData set, then it must be fit with a negative binomial ',
         'GLM in order to extract residual variance. If seeking to plot the ',
         'mean-variance trend of unmodeled count data, then perform some variance',
         'stabilizing transformation on the count matrix, e.g. vst or rlog, and ',
         'pass the resulting matrix to dat. See ?plot_mv for more details.')
  }
  if (!trans %in% c('rank', 'log', 'sqrt')) {
    stop('trans must be one of "rank", "log", or "sqrt".')
  }
  if (trans == 'sqrt' && (is(dat, 'MArrayLM') || is(dat, 'DESeqDataSet'))) {
    warning('The square root transform is only recommended for unmodeled count data. ',
            'Consider using trans = "rank" or "log" when passing an object of class ',
            'MArrayLM or DESeqDataSet.')
  }
  if (is.null(main)) main <- 'Mean-Variance Plot'
  if (!legend %in% c('outside', 'bottomleft', 'bottomright', 'topleft', 'topright')) {
    stop('legend must be one of "outside", "bottomleft", "bottomright" ',
         '"topleft", or "topright".')
  }

  # Tidy data
  if (is.null(rownames(dat))) probes <- seq_len(nrow(dat))
  else probes <- rownames(dat)
  if (!is(dat, 'MArrayLM') && !is(dat, 'DESeqDataSet')) {
    dat <- getEAWP(dat)$expr
    keep <- rowSums(is.finite(dat)) == ncol(dat)
    dat <- dat[keep, , drop = FALSE]
    mu <- rowMeans(dat)
    sigma <- rowSds(dat)
  } else if (is(dat, 'MArrayLM')) {
    mu <- dat$Amean
    sigma <- dat$sigma
    if ('s2.prior' %in% names(dat)) prior <- sqrt(dat$s2.prior)
  } else if (is(dat, 'DESeqDataSet')) {
    fit <- assays(dat)[['mu']]
    keep <- rowSums(is.finite(fit)) == ncol(fit)
    fit <- lcpm(fit[keep, , drop = FALSE])
    dat <- dat[keep, , drop = FALSE]
    cnts <- lcpm(counts(dat))
    resids <- cnts - fit
    mu <- rowMeans(cnts)
    sigma <- rowSds(resids)
  }
  if (trans == 'rank') {                    # Apply transformations
    mu <- rank(mu, ties.method = 'random')
    xlab <- expression('Rank'*(mu))
    ylab <- expression(sigma)
  } else if (trans == 'log') {
    sigma <- log2(sigma)
    if ('s2.prior' %in% names(dat)) prior <- log2(prior)
    xlab <- expression(mu)
    ylab <- expression('log'[2]*(sigma))
  } else if (trans == 'sqrt') {
    sigma <- sqrt(sigma)
    if ('s2.prior' %in% names(dat)) prior <- sqrt(prior)
    xlab <- expression(mu)
    ylab <- expression(sqrt(sigma))
  }
  lo <- lowess(mu, sigma, f = span)
  df <- data_frame(Probe = probes,
                      Mu = mu,
                   Sigma = sigma,
                   Mu_lo = lo[['x']],
                Sigma_lo = lo[['y']])
  if ('s2.prior' %in% names(dat)) {
    df <- df %>% mutate(Prior = prior)
    if (length(dat$s2.prior) > 1L) {          # Check for outliers
      s2 <- dat$sigma^2L / dat$s2.prior
      pdn <- pf(s2, df1 = dat$df.residual, df2 = max(dat$df.prior))
      pup <- pf(s2, df1 = dat$df.residual, df2 = max(dat$df.prior), lower.tail = FALSE)
      FDR <- p.adjust(2L * pmin(pdn, pup), method = 'BH')
      df <- df %>% mutate(Outlier = map_lgl(seq_len(nrow(dat)), function(i) {
        ifelse(FDR[i] <= 0.05, TRUE, FALSE)
      }))
    }
  }

  # Build plot
  p <- ggplot(df) +
    labs(title = main, x = xlab, y = ylab) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
  if ('Outlier' %in% colnames(df) && any(df$Outlier)) {
    suppressWarnings(
      p <- p + geom_point(aes(Mu, Sigma, text = Probe, color = Outlier),
                          size = ptsize, alpha = 0.25)
    )
  } else {
    suppressWarnings(
      p <- p + geom_point(aes(Mu, Sigma, text = Probe),
                          size = ptsize, alpha = 0.25)
    )
  }
  if ('Prior' %in% colnames(df)) {          # Plot prior
    p <- p + geom_smooth(aes(Mu_lo, Sigma_lo, color = 'LOWESS fit'),
                         method = 'gam', formula = y ~ s(x, bs = 'cs'),
                         size = 0.5, se = FALSE)
    if (length(dat$s2.prior) == 1L) {
      p <- p + geom_abline(aes(color = 'Prior'), slope = 0, intercept = prior)
    } else {
      p <- p + geom_smooth(aes(Mu, Prior, color = 'Prior'),
                           method = 'gam', formula = y ~ s(x, bs = 'cs'),
                           size = 0.5, se = FALSE)
    }
    p <- p + scale_color_manual(name = 'Curves', values = c('red', 'blue')) +
      guides(col = guide_legend(reverse = TRUE))
  } else {
    p <- p + geom_smooth(aes(Mu_lo, Sigma_lo),
                         method = 'gam', formula = y ~ s(x, bs = 'cs'),
                         size = 0.5, se = FALSE)
  }
  if (legend == 'bottomleft') {             # Locate legend
    p <- p + theme(legend.justification = c(0.01, 0.01),
                   legend.position = c(0.01, 0.01))
  } else if (legend == 'bottomright') {
    p <- p + theme(legend.justification = c(0.99, 0.01),
                   legend.position = c(0.99, 0.01))
  } else if (legend == 'topleft') {
    p <- p + theme(legend.justification = c(0.01, 0.99),
                   legend.position = c(0.01, 0.99))
  } else if (legend == 'topright') {
    p <- p + theme(legend.justification = c(0.99, 0.99),
                   legend.position = c(0.99, 0.99))
  }

  # Output
  if (!hover) {
    print(p)
  } else {
    if (legend == 'outside' && 'Prior' %in% colnames(df)) {
      p <- ggplotly(p, tooltip = 'text', height = 525, width = 600)
    } else {
      p <- ggplotly(p, tooltip = 'text', height = 600, width = 600)
    }
    print(p)
  }

}

# Add ggrepel functionality?

