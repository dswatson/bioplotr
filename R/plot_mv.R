#' Mean-Variance Plot
#'
#' This function visualizes the mean-variance relationship of omic data before
#' or after modeling.
#'
#' @param dat Omic data matrix or matrix-like object with rows corresponding to probes
#'   and columns to samples. Data are presumed to be filtered and normalized prior to
#'   visualization. Alternatively, a fitted model object from the \code{limma, edgeR},
#'   or \code{DESeq2} pipelines. See Details.
#' @param trans Data transformation to be applied to probewise means (if \code{trans =
#'   "rank"}) or standard deviations (if \code{trans = "log"} or \code{"sqrt"}). Not all
#'   transformations are appropriate for all data types. See Details.
#' @param span Width of the LOWESS smoothing window as a proportion.
#' @param title Optional plot title.
#' @param xlab Optional label for x-axis.
#' @param ylab Optional label for y-axis.
#' @param legend Legend position. Must be one of \code{"outside", "bottomleft",
#'   "bottomright", "topleft",} or \code{"topright"}. Only relevant if \code{dat}
#'   is an \code{MArrayLM} object created by a call to \code{\link[limma]{eBayes}}
#'   with \code{trend = TRUE}. See \code{\link[limma]{squeezeVar}} for more details.
#' @param hover Show probe name by hovering mouse over data point? If \code{TRUE},
#'   the plot is rendered in HTML and will either open in your browser's graphic
#'   display or appear in the RStudio viewer. Probe names are extracted from
#'   \code{dat}.
#'
#' @details
#' Mean-variance (MV) plots are a quick and easy way to visualize the relationship
#' between the first two moments of probewise data distributions. When used prior to
#' modeling, they may help better understand the internal structure of the data
#' and inspect for potential outliers. The effects of filtering and transformations
#' can also be readily evaluated. When applied after modeling, MV plots help assess
#' the assumptions of the regression.
#'
#' If \code{dat} is a matrix, then it is presumed to be filtered and normalized prior
#' to plotting. For count data, this means undergoing some sort of variance
#' stabilizing transformation, such as \code{\link[edgeR]{cpm} (with \code{log = TRUE}),
#' \link[DESeq2]{vst}, \link[DESeq2]{rlog}}, etc. If \code{dat} is of class \code{
#' \link[limma]{MArrayLM}}, \code{\link[edgeR]{DGEGLM}} or \code{\link[DESeq2]{
#' DESeqDataSet}}, then the y-axis represents residual variance. For data that has
#' been fit with a negative binomial model, a residual matrix is generated by
#' subtracting the normalized signal matrix from the normalized counts on the
#' log2-CPM scale.
#'
#' By default, rank-transformed means are plotted against standard deviations for
#' each probe. This is a reasonable choice for most data types. It is also common in
#' the microarray literature to plot probewise means against log-transformed standard
#' deviations, while the \code{limma} authors recommend the square-root transform for
#' count data on the log2-CPM scale.
#'
#' \code{plot_mv} fits a LOWESS curve to the points with a smoothing window given
#' by \code{span}. If standard errors were moderated with \code{eBayes}, then prior
#' variance will also be plotted as either a horizontal line or a smooth curve,
#' depending on whether a global or intensity-dependent prior was used. If robust
#' empirical Bayes was used to create \code{dat}, then outlier variances are
#' highlighted. See \code{\link[limma]{squeezeVar}} for more details.
#'
#' @references
#' Huber, W., Hedebreck, A., SÃ¼ltmann, H., Poustka, A. & Vingron, M. (2002).
#' \href{https://www.ncbi.nlm.nih.gov/pubmed/12169536}{Variance Stabilization Applied
#' to Microarray Data Calibration and to the Quantification of Differential Expression}.
#' \emph{Bioinformatics, 18}:1, S96-2104.
#'
#' Sartor, M.A., Tomlinson, C.R., Wesselkamper, S.C., Sivaganesan, S., Leikauf, G.D.
#' & Medvedovic, M. (2006).
#' \href{http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-7-538}{Intensity-based
#' hierarchical Bayes method improves testing for differentially expressed genes in
#' microarray experiments}. \emph{BMC Bioinformatics}, \strong{7}:538.
#'
#' Law, C.W., Chen, Y., Shi, W., & Smyth, G.K. (2014).
#' \href{https://genomebiology.biomedcentral.com/articles/10.1186/gb-2014-15-2-r29}{voom:
#' precision weights unlock linear model analysis tools for RNA-seq read counts}.
#' \emph{Genome Biology}, \strong{15}:R29.
#'
#' @examples
#' mat <- matrix(rnorm(1000 * 10), nrow = 1000, ncol = 10)
#' plot_mv(mat, trans = "log")
#'
#' library(limma)
#' grp <- rep(c("ctl", "trt"), each = 5)
#' des <- model.matrix(~ grp)
#' fit <- eBayes(lmFit(mat, des), trend = TRUE)
#' plot_mv(fit)
#'
#' @seealso
#' \code{\link[edgeR]{plotMeanVar, dglmStdResid}, \link[vsn]{meanSdPlot},
#' \link[limma]{plotSA}, \link[limma]{voom}}
#'
#' @export
#' @importFrom limma getEAWP
#' @importFrom DESeq2 counts sizeFactors normalizationFactors
#' @importFrom SummarizedExperiment assay assays
#' @importFrom matrixStats rowSds
#' @importFrom ggsci pal_d3
#' @import dplyr
#' @import ggplot2
#' @importFrom plotly ggplotly
#'

plot_mv <- function(dat,
                    trans = 'rank',
                     span = 0.5,
                    title = NULL,
                   legend = 'outside',
                    hover = FALSE) {

  # Preliminaries
  if (nrow(dat) < 2L) {
    stop('plot_mv requires at least 2 probes to fit a mean-variance trend.')
  }
  if (is(dat, 'MArrayLM') & is.null(dat$t) & is.null(dat$F)) {
    warning('Standard errors for dat have not been moderated. Consider re-running ',
            'plot_mv after shrinking residual variance with eBayes. See ?eBayes ',
            'and ?squeezeVar for more info.')
  } else if (is(dat, 'DESeqDataSet') & is.null(assays(dat)[['mu']])) {
    stop('If dat is a DESeqData set, then it must be fit with a negative binomial ',
         'GLM in order to extract residual variance. If seeking to plot the ',
         'mean-variance trend of unmodeled count data, then perform some variance',
         'stabilizing transformation on the count matrix, e.g. vst or rlog, and ',
         'pass the resulting matrix as dat. See ?plot_mv for more details.')
  }
  if (!trans %in% c('rank', 'log', 'sqrt')) {
    stop('trans must be one of "rank", "log", or "sqrt".')
  }
  if (is.null(title)) {
    title <- 'Mean-Variance Plot'
  }
  if (!legend %in% c('outside', 'bottomleft', 'bottomright', 'topleft', 'topright')) {
    stop('legend must be one of "outside", "bottomleft", "bottomright" ',
         '"topleft", or "topright".')
  }

  # Tidy data
  if (!is(dat, 'MArrayLM') & !is(dat, 'DGEGLM') & !is(dat, 'DESeqDataSet')) {
    dat <- getEAWP(dat)$expr
    keep <- rowSums(is.finite(dat)) == ncol(dat)
    dat <- dat[keep, , drop = FALSE]
    mu <- rowMeans(dat)
    sigma <- rowSds(dat)
  } else if (is(dat, 'MArrayLM')) {
    mu <- dat$Amean
    sigma <- dat$sigma
    if ('s2.prior' %in% names(dat)) {
      prior <- sqrt(dat$s2.prior)
    }
  } else if (is(dat, 'DGEGLM')) {
    lib.size <- with(dat$samples, lib.size * norm.factors)
    cnts <- t(log2(t(dat$counts) + 0.5) / (lib.size + 1L) * 1e6L)
    fit <- t(log2(t(dat$fitted.values) + 0.5) / (lib.size + 1L) * 1e6L)
    resids <- cnts - fit
    mu <- dat$AveLogCPM
    sigma <- rowSds(resids)
  } else if (is(dat, 'DESeqDataSet')) {
    keep <- mcols(dat)$baseMean > 0L
    dat <- dat[keep, , drop = FALSE]
    libs <- colSums(counts(dat))
    if (is.null(sizeFactors(dat))) {
      lib.size <- t(t(normalizationFactors(dat)) * libs)
      cnts <- log2((counts(dat) + 0.5) / (lib.size + 1L) * 1e6L)
      fit <- log2((assays(dat)[['mu']] + 0.5) / (lib.size + 1L) * 1e6L)
      dge_cnts <- DGEList(counts(dat))
      dge_cnts <- calcNormFactors(dge_cnts, method = 'RLE')
    } else {
      lib.size <- sizeFactors(dat) * libs
      cnts <- t(log2(t(counts(dat) + 0.5) / (lib.size + 1L) * 1e6L))
      fit <- t(log2(t(assays(dat)[['mu']] + 0.5) / (lib.size + 1L) * 1e6L))
      dge_cnts <- DGEList(counts(dat))
      dge_cnts$samples$norm.factors <- sizeFactors(dat)
    }
    resids <- cnts - fit
    mu <- aveLogCPM(dge_cnts, prior.count = 1L, dispersion = dispersions(dat))
    sigma <- rowSds(resids)
  }
  if (trans == 'rank') {                         # Apply transformations
    mu <- rank(mu, ties.method = 'random')
    if (is.null(xlab)) xlab <- expression('Rank'*(mu))
    if (is.null(ylab)) ylab <- expression(sigma)
  } else if (trans == 'log') {
    sigma <- log2(sigma)
    if ('s2.prior' %in% names(dat)) prior <- log2(prior)
    if (is.null(xlab)) xlab <- expression(mu)
    if (is.null(ylab)) ylab <- expression('log'[2]*(sigma))
  } else if (trans == 'sqrt') {
    sigma <- sqrt(sigma)
    if ('s2.prior' %in% names(dat)) prior <- sqrt(prior)
    if (is.null(xlab)) xlab <- expression(mu)
    if (is.null(ylab)) ylab <- expression(sqrt(sigma))
  }
  lo <- lowess(mu, sigma, f = span)
  if (is.null(rownames(dat))) {
    probes <- seq_len(nrow(dat))
  } else {
    probes <- rownames(dat)
  }
  df <- data_frame(Probe = probes,
                      Mu = mu,
                   Sigma = sigma,
                   Mu_lo = lo[['x']],
                Sigma_lo = lo[['y']])
  if ('s2.prior' %in% names(dat)) {
    df <- df %>% mutate(Prior = prior)
    if (length(dat$s2.prior) > 1L) {             # Check for outliers
      s2 <- dat$sigma^2L / dat$s2.prior
      pdn <- pf(s2, df1 = dat$df.residual, df2 = max(dat$df.prior))
      pup <- pf(s2, df1 = dat$df.residual, df2 = max(dat$df.prior), lower.tail = FALSE)
      FDR <- p.adjust(2L * pmin(pdn, pup), method = 'BH')
      df <- df %>% mutate(Outlier = ifelse(FDR <= 0.05, TRUE, FALSE))
    }
  }

  # Build plot
  size <- probe_ptsize(df)
  alpha <- probe_alpha(df)
  p <- ggplot(df) +
    labs(title = title, x = xlab, y = ylab) +
    theme_bw() +
    theme(plot.title = element_text(hjust = 0.5))
  if (suppressWarnings(any(df$Outlier))) {       # Plot outliers
    suppressWarnings(
      p <- p + geom_point(aes(Mu, Sigma, text = Probe, color = Outlier),
                          size = size, alpha = alpha,
                          color = c(pal_d3()(4)[4], 'black'))
    )
  } else {
    suppressWarnings(
      p <- p + geom_point(aes(Mu, Sigma, text = Probe),
                          size = size, alpha = alpha)
    )
  }
  if ('s2.prior' %in% names(dat)) {              # Plot prior
    p <- p + geom_smooth(aes(Mu_lo, Sigma_lo, color = 'LOWESS fit'),
                         method = 'gam', formula = y ~ s(x, bs = 'cs'),
                         size = 0.5, se = FALSE)
    if (length(dat$s2.prior) == 1L) {
      p <- p + geom_hline(aes(color = 'Prior', yintercept = Prior))
    } else {
      p <- p + geom_smooth(aes(Mu, Prior, color = 'Prior'),
                           method = 'gam', formula = y ~ s(x, bs = 'cs'),
                           size = 0.5, se = FALSE)
    }
    p <- p + scale_color_manual(name = 'Curves', values = pal_d3()(2),
                                guide = guide_legend(reverse = TRUE))
  } else {
    p <- p + geom_smooth(aes(Mu_lo, Sigma_lo, color = 'LOWESS fit'),
                         method = 'gam', formula = y ~ s(x, bs = 'cs'),
                         size = 0.5, se = FALSE) +
      scale_color_manual(name = 'Curve', values = pal_d3()(1))
  }
  if (legend == 'bottomleft') {                  # Locate legend
    p <- p + theme(legend.justification = c(0.01, 0.01),
                   legend.position = c(0.01, 0.01))
  } else if (legend == 'bottomright') {
    p <- p + theme(legend.justification = c(0.99, 0.01),
                   legend.position = c(0.99, 0.01))
  } else if (legend == 'topleft') {
    p <- p + theme(legend.justification = c(0.01, 0.99),
                   legend.position = c(0.01, 0.99))
  } else if (legend == 'topright') {
    p <- p + theme(legend.justification = c(0.99, 0.99),
                   legend.position = c(0.99, 0.99))
  }

  # Output
  if (!hover) {
    print(p)
  } else {
    if (legend == 'outside' && !is.null(df$Prior)) {
      p <- ggplotly(p, tooltip = 'text', height = 525, width = 600)
    } else {
      p <- ggplotly(p, tooltip = 'text', height = 600, width = 600)
    }
    print(p)
  }

}

# Add option for pre-model count data where var = mu + mu^2 * disp?
# Add ggrepel functionality?

